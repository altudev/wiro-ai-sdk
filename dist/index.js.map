{
  "version": 3,
  "sources": ["..\\src\\auth.ts", "..\\src\\client.ts"],
  "sourcesContent": [
    "import { createHmac } from 'crypto';\r\n\r\n/**\r\n * Authentication headers required by the Wiro AI API.\r\n */\r\nexport interface WiroAuthHeaders {\r\n  'x-api-key': string;\r\n  'x-nonce': string;\r\n  'x-signature': string;\r\n}\r\n\r\n/**\r\n * Generate authentication headers for Wiro AI API requests.\r\n *\r\n * The Wiro AI API uses HMAC-SHA256 authentication with the following formula:\r\n * - nonce: Unix timestamp (seconds since epoch)\r\n * - signature: HMAC-SHA256(apiSecret + nonce, apiKey)\r\n *\r\n * @param apiKey - Your Wiro project API key (required, minimum 8 characters)\r\n * @param apiSecret - Your Wiro project API secret (required, minimum 8 characters)\r\n * @returns Authentication headers object\r\n * @throws Error if apiKey or apiSecret is empty or too short\r\n *\r\n * @example\r\n * ```ts\r\n * const headers = generateAuthHeaders('my-api-key', 'my-api-secret');\r\n * // Returns:\r\n * // {\r\n * //   'x-api-key': 'my-api-key',\r\n * //   'x-nonce': '1734513807',\r\n * //   'x-signature': 'abc123...'\r\n * // }\r\n * ```\r\n */\r\nexport function generateAuthHeaders(apiKey: string, apiSecret: string): WiroAuthHeaders {\r\n  // Validate credentials\r\n  if (!apiKey || apiKey.length < 8) {\r\n    throw new Error('Invalid apiKey: must be at least 8 characters long');\r\n  }\r\n  if (!apiSecret || apiSecret.length < 8) {\r\n    throw new Error('Invalid apiSecret: must be at least 8 characters long');\r\n  }\r\n\r\n  // Generate nonce as Unix timestamp in seconds\r\n  const nonce = Math.floor(Date.now() / 1000).toString();\r\n  \r\n  // Create HMAC-SHA256 signature\r\n  // Formula: HMAC-SHA256(apiSecret + nonce, apiKey)\r\n  const message = apiSecret + nonce;\r\n  const hmac = createHmac('sha256', apiKey);\r\n  hmac.update(message);\r\n  const signature = hmac.digest('hex');\r\n\r\n  return {\r\n    'x-api-key': apiKey,\r\n    'x-nonce': nonce,\r\n    'x-signature': signature,\r\n  };\r\n}\r\n",
    "import { generateAuthHeaders } from './auth.ts';\r\nimport type {\r\n  WiroClientOptions,\r\n  WiroFileParam,\r\n  RunResponse,\r\n  TaskDetailResponse,\r\n  TaskDetailRequest,\r\n  KillTaskResponse,\r\n  KillTaskRequest,\r\n  CancelTaskResponse,\r\n  CancelTaskRequest,\r\n} from './types/index.ts';\r\n\r\n/**\r\n * Client library for interacting with the Wiro AI API.\r\n *\r\n * This client provides methods to run AI models, check task status, and manage tasks.\r\n * It uses Bun's native fetch API for HTTP requests and supports file uploads via FormData.\r\n *\r\n * @example\r\n * ```ts\r\n * import { WiroClient } from 'wiro-ai-sdk';\r\n *\r\n * const client = new WiroClient({ \r\n *   apiKey: 'your_key', \r\n *   apiSecret: 'your_secret' \r\n * });\r\n * \r\n * // Run a model with parameters\r\n * const runResult = await client.run('wiro', 'professional-headshot', {\r\n *   background: 'neutral',\r\n *   outputFormat: 'jpeg',\r\n *   callbackUrl: 'https://example.com/callback'\r\n * });\r\n *\r\n * // Get task details\r\n * const taskId = runResult.taskid!;\r\n * const detail = await client.getTaskDetail({ taskid: taskId });\r\n * console.log('Task status:', detail.tasklist[0]?.status);\r\n * \r\n * // Run a model with file upload\r\n * const runWithFile = await client.run('wiro', 'polaroid-effect', {\r\n *   effectType: 'polaroid_smile',\r\n *   seed: 42,\r\n * }, [\r\n *   { name: 'inputImage', file: '/path/to/image.jpg' }\r\n * ]);\r\n * ```\r\n */\r\nexport class WiroClient {\r\n  private readonly apiKey: string;\r\n  private readonly apiSecret: string;\r\n  private readonly baseUrl: string;\r\n\r\n  constructor(options: WiroClientOptions) {\r\n    const { apiKey, apiSecret, baseUrl = 'https://api.wiro.ai/v1' } = options;\r\n\r\n    if (!apiKey) {\r\n      throw new Error('WiroClient requires an apiKey');\r\n    }\r\n    if (!apiSecret) {\r\n      throw new Error('WiroClient requires an apiSecret');\r\n    }\r\n\r\n    // Validate baseUrl\r\n    if (baseUrl && !baseUrl.startsWith('http://') && !baseUrl.startsWith('https://')) {\r\n      throw new Error('Invalid baseUrl: must start with http:// or https://');\r\n    }\r\n\r\n    this.apiKey = apiKey;\r\n    this.apiSecret = apiSecret;\r\n    this.baseUrl = baseUrl.replace(/\\/$/, ''); // Remove trailing slash\r\n  }\r\n\r\n  /**\r\n   * Run a Wiro AI model. You must provide the owner (e.g. \"wiro\") and model slug\r\n   * (e.g. \"professional-headshot\"). Parameters specific to the model can be passed as\r\n   * an object. Files can optionally be attached; supply them via the `files` array.\r\n   *\r\n   * @param owner - The owner/namespace of the model (e.g., \"wiro\")\r\n   * @param model - The model slug/name (e.g., \"professional-headshot\")\r\n   * @param params - Object representing JSON parameters accepted by the model\r\n   * @param files - Optional array of file parameters. Each file will be appended to a\r\n   *                multipart form under its `name` property.\r\n   * @returns Promise resolving to the API response with taskid and socketaccesstoken\r\n   * \r\n   * @example\r\n   * ```ts\r\n   * // Run without files\r\n   * const result = await client.run('wiro', 'professional-headshot', {\r\n   *   inputImageUrl: 'https://example.com/photo.jpg',\r\n   *   background: 'neutral'\r\n   * });\r\n   * \r\n   * // Run with file upload\r\n   * const result = await client.run('wiro', 'polaroid-effect', {\r\n   *   effectType: 'polaroid_smile'\r\n   * }, [\r\n   *   { name: 'inputImage', file: './photo.jpg' }\r\n   * ]);\r\n   * ```\r\n   */\r\n  async run<T = any>(\r\n    owner: string,\r\n    model: string,\r\n    params: Record<string, any>,\r\n    files?: WiroFileParam[]\r\n  ): Promise<RunResponse & { data?: T }> {\r\n    const authHeaders = generateAuthHeaders(this.apiKey, this.apiSecret);\r\n    const url = `${this.baseUrl}/Run/${owner}/${model}`;\r\n\r\n    let body: FormData | string;\r\n    let headers: Record<string, string>;\r\n\r\n    // When files are present, construct a FormData body. Otherwise send JSON.\r\n    if (files && files.length > 0) {\r\n      const form = new FormData();\r\n      \r\n      // Append provided parameters to the form\r\n      if (params) {\r\n        for (const [key, value] of Object.entries(params)) {\r\n          if (value === undefined || value === null) continue;\r\n          \r\n          if (Array.isArray(value)) {\r\n            // FormData supports duplicate keys for arrays\r\n            value.forEach(v => form.append(key, String(v)));\r\n          } else {\r\n            form.append(key, String(value));\r\n          }\r\n        }\r\n      }\r\n      \r\n      // Append files to the form\r\n      for (const fileParam of files) {\r\n        let fileData: Blob | File;\r\n        let filename = fileParam.filename;\r\n\r\n        // If the file is a string, treat it as a path and read using Bun.file()\r\n        if (typeof fileParam.file === 'string') {\r\n          try {\r\n            const bunFile = Bun.file(fileParam.file);\r\n            fileData = bunFile;\r\n\r\n            // Extract filename from path if not provided\r\n            if (!filename) {\r\n              const pathParts = fileParam.file.split(/[/\\\\]/);\r\n              filename = pathParts[pathParts.length - 1] || fileParam.name;\r\n            }\r\n          } catch (error) {\r\n            const errorMsg = error instanceof Error ? error.message : String(error);\r\n            throw new Error(`Failed to read file at \"${fileParam.file}\": ${errorMsg}`);\r\n          }\r\n        } else {\r\n          // File is already a Blob or File\r\n          fileData = fileParam.file;\r\n\r\n          // Use the File's name if available, otherwise generate one\r\n          if (!filename) {\r\n            if ('name' in fileData && fileData.name) {\r\n              filename = fileData.name;\r\n            } else {\r\n              filename = `${fileParam.name}.bin`;\r\n            }\r\n          }\r\n        }\r\n\r\n        form.append(fileParam.name, fileData, filename);\r\n      }\r\n      \r\n      body = form;\r\n      // Don't set Content-Type - let fetch set it with the boundary\r\n      headers = { ...authHeaders };\r\n    } else {\r\n      // Send parameters as JSON\r\n      body = JSON.stringify(params);\r\n      headers = {\r\n        ...authHeaders,\r\n        'Content-Type': 'application/json',\r\n      };\r\n    }\r\n\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers,\r\n      body,\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(`Wiro API request failed: ${response.status} ${response.statusText} - ${errorText}`);\r\n    }\r\n\r\n    return response.json() as Promise<RunResponse & { data?: T }>;\r\n  }\r\n\r\n  /**\r\n   * Retrieve details about one or more tasks. You can supply either a task ID or a\r\n   * socket access token. At least one of these properties must be provided.\r\n   *\r\n   * @param taskInfo - An object containing either a `taskid` or `tasktoken` field\r\n   * @returns Promise resolving to task details including status and outputs\r\n   * \r\n   * @example\r\n   * ```ts\r\n   * // Get task by ID\r\n   * const detail = await client.getTaskDetail({ taskid: '2221' });\r\n   * \r\n   * // Get task by token\r\n   * const detail = await client.getTaskDetail({ \r\n   *   tasktoken: 'eDcCm5yyUfIvMFspTwww49OUfgXkQt' \r\n   * });\r\n   * \r\n   * // Check task status\r\n   * const task = detail.tasklist[0];\r\n   * if (task.status === 'task_postprocess_end') {\r\n   *   console.log('Task completed!', task.outputs);\r\n   * }\r\n   * ```\r\n   */\r\n  async getTaskDetail<T = any>(taskInfo: TaskDetailRequest): Promise<TaskDetailResponse<T>> {\r\n    if (!taskInfo.taskid && !taskInfo.tasktoken) {\r\n      throw new Error('getTaskDetail requires either a taskid or a tasktoken');\r\n    }\r\n\r\n    const authHeaders = generateAuthHeaders(this.apiKey, this.apiSecret);\r\n    const url = `${this.baseUrl}/Task/Detail`;\r\n\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        ...authHeaders,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(taskInfo),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(`Wiro API request failed: ${response.status} ${response.statusText} - ${errorText}`);\r\n    }\r\n\r\n    return response.json() as Promise<TaskDetailResponse<T>>;\r\n  }\r\n\r\n  /**\r\n   * Kill a running task. Provide either the task ID or the socket access token.\r\n   * Use this to terminate tasks that are currently executing.\r\n   *\r\n   * @param taskInfo - An object containing either `taskid` or `tasktoken`\r\n   * @returns Promise resolving to the kill task response\r\n   * \r\n   * @example\r\n   * ```ts\r\n   * // Kill by task ID\r\n   * await client.killTask({ taskid: '534574' });\r\n   * \r\n   * // Kill by token\r\n   * await client.killTask({ \r\n   *   tasktoken: 'ZpYote30on42O4jjHXNiKmrWAZqbRE' \r\n   * });\r\n   * ```\r\n   */\r\n  async killTask(taskInfo: KillTaskRequest): Promise<KillTaskResponse> {\r\n    if (!taskInfo.taskid && !taskInfo.tasktoken) {\r\n      throw new Error('killTask requires either a taskid or a tasktoken');\r\n    }\r\n\r\n    const authHeaders = generateAuthHeaders(this.apiKey, this.apiSecret);\r\n    const url = `${this.baseUrl}/Task/Kill`;\r\n\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        ...authHeaders,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify(taskInfo),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(`Wiro API request failed: ${response.status} ${response.statusText} - ${errorText}`);\r\n    }\r\n\r\n    return response.json() as Promise<KillTaskResponse>;\r\n  }\r\n\r\n  /**\r\n   * Cancel a queued task by its task ID. Use this for tasks that are waiting in the queue\r\n   * and have not started execution yet.\r\n   *\r\n   * @param taskid - The task ID to cancel\r\n   * @returns Promise resolving to the cancel task response\r\n   * \r\n   * @example\r\n   * ```ts\r\n   * await client.cancelTask('634574');\r\n   * ```\r\n   */\r\n  async cancelTask(taskid: string): Promise<CancelTaskResponse> {\r\n    const authHeaders = generateAuthHeaders(this.apiKey, this.apiSecret);\r\n    const url = `${this.baseUrl}/Task/Cancel`;\r\n\r\n    const response = await fetch(url, {\r\n      method: 'POST',\r\n      headers: {\r\n        ...authHeaders,\r\n        'Content-Type': 'application/json',\r\n      },\r\n      body: JSON.stringify({ taskid }),\r\n    });\r\n\r\n    if (!response.ok) {\r\n      const errorText = await response.text();\r\n      throw new Error(`Wiro API request failed: ${response.status} ${response.statusText} - ${errorText}`);\r\n    }\r\n\r\n    return response.json() as Promise<CancelTaskResponse>;\r\n  }\r\n}\r\n"
  ],
  "mappings": "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",
  "debugId": "D319ED8A1EB299F364756E2164756E21",
  "names": []
}