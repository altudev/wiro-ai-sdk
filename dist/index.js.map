{
  "version": 3,
  "sources": ["../src/auth.ts", "../src/client.ts"],
  "sourcesContent": [
    "import { createHmac } from 'crypto';\n\n/**\n * Authentication headers required by the Wiro AI API.\n */\nexport interface WiroAuthHeaders {\n  'x-api-key': string;\n  'x-nonce': string;\n  'x-signature': string;\n}\n\n/**\n * Generate authentication headers for Wiro AI API requests.\n *\n * The Wiro AI API uses HMAC-SHA256 authentication with the following formula:\n * - nonce: Unix timestamp (seconds since epoch)\n * - signature: HMAC-SHA256(apiSecret + nonce, apiKey)\n *\n * @param apiKey - Your Wiro project API key (required, minimum 8 characters)\n * @param apiSecret - Your Wiro project API secret (required, minimum 8 characters)\n * @returns Authentication headers object\n * @throws Error if apiKey or apiSecret is empty or too short\n *\n * @example\n * ```ts\n * const headers = generateAuthHeaders('my-api-key', 'my-api-secret');\n * // Returns:\n * // {\n * //   'x-api-key': 'my-api-key',\n * //   'x-nonce': '1734513807',\n * //   'x-signature': 'abc123...'\n * // }\n * ```\n */\nexport function generateAuthHeaders(apiKey: string, apiSecret: string): WiroAuthHeaders {\n  // Validate credentials\n  if (!apiKey || apiKey.length < 8) {\n    throw new Error('Invalid apiKey: must be at least 8 characters long');\n  }\n  if (!apiSecret || apiSecret.length < 8) {\n    throw new Error('Invalid apiSecret: must be at least 8 characters long');\n  }\n\n  // Generate nonce as Unix timestamp in seconds\n  const nonce = Math.floor(Date.now() / 1000).toString();\n  \n  // Create HMAC-SHA256 signature\n  // Formula: HMAC-SHA256(apiSecret + nonce, apiKey)\n  const message = apiSecret + nonce;\n  const hmac = createHmac('sha256', apiKey);\n  hmac.update(message);\n  const signature = hmac.digest('hex');\n\n  return {\n    'x-api-key': apiKey,\n    'x-nonce': nonce,\n    'x-signature': signature,\n  };\n}\n",
    "import { generateAuthHeaders } from './auth.ts';\nimport type {\n  WiroClientOptions,\n  WiroFileParam,\n  RunResponse,\n  TaskDetailResponse,\n  TaskDetailRequest,\n  KillTaskResponse,\n  KillTaskRequest,\n  CancelTaskResponse,\n  CancelTaskRequest,\n} from './types/index.ts';\n\n/**\n * Client library for interacting with the Wiro AI API.\n *\n * This client provides methods to run AI models, check task status, and manage tasks.\n * It uses Bun's native fetch API for HTTP requests and supports file uploads via FormData.\n *\n * @example\n * ```ts\n * import { WiroClient } from 'wiro-ai-sdk';\n *\n * const client = new WiroClient({ \n *   apiKey: 'your_key', \n *   apiSecret: 'your_secret' \n * });\n * \n * // Run a model with parameters\n * const runResult = await client.run('wiro', 'professional-headshot', {\n *   background: 'neutral',\n *   outputFormat: 'jpeg',\n *   callbackUrl: 'https://example.com/callback'\n * });\n *\n * // Get task details\n * const taskId = runResult.taskid!;\n * const detail = await client.getTaskDetail({ taskid: taskId });\n * console.log('Task status:', detail.tasklist[0]?.status);\n * \n * // Run a model with file upload\n * const runWithFile = await client.run('wiro', 'polaroid-effect', {\n *   effectType: 'polaroid_smile',\n *   seed: 42,\n * }, [\n *   { name: 'inputImage', file: '/path/to/image.jpg' }\n * ]);\n * ```\n */\nexport class WiroClient {\n  private readonly apiKey: string;\n  private readonly apiSecret: string;\n  private readonly baseUrl: string;\n\n  constructor(options: WiroClientOptions) {\n    const { apiKey, apiSecret, baseUrl = 'https://api.wiro.ai/v1' } = options;\n\n    if (!apiKey) {\n      throw new Error('WiroClient requires an apiKey');\n    }\n    if (!apiSecret) {\n      throw new Error('WiroClient requires an apiSecret');\n    }\n\n    // Validate baseUrl\n    if (baseUrl && !baseUrl.startsWith('http://') && !baseUrl.startsWith('https://')) {\n      throw new Error('Invalid baseUrl: must start with http:// or https://');\n    }\n\n    this.apiKey = apiKey;\n    this.apiSecret = apiSecret;\n    this.baseUrl = baseUrl.replace(/\\/$/, ''); // Remove trailing slash\n  }\n\n  /**\n   * Run a Wiro AI model. You must provide the owner (e.g. \"wiro\") and model slug\n   * (e.g. \"professional-headshot\"). Parameters specific to the model can be passed as\n   * an object. Files can optionally be attached; supply them via the `files` array.\n   *\n   * @param owner - The owner/namespace of the model (e.g., \"wiro\")\n   * @param model - The model slug/name (e.g., \"professional-headshot\")\n   * @param params - Object representing JSON parameters accepted by the model\n   * @param files - Optional array of file parameters. Each file will be appended to a\n   *                multipart form under its `name` property.\n   * @returns Promise resolving to the API response with taskid and socketaccesstoken\n   * \n   * @example\n   * ```ts\n   * // Run without files\n   * const result = await client.run('wiro', 'professional-headshot', {\n   *   inputImageUrl: 'https://example.com/photo.jpg',\n   *   background: 'neutral'\n   * });\n   * \n   * // Run with file upload\n   * const result = await client.run('wiro', 'polaroid-effect', {\n   *   effectType: 'polaroid_smile'\n   * }, [\n   *   { name: 'inputImage', file: './photo.jpg' }\n   * ]);\n   * ```\n   */\n  async run<T = any>(\n    owner: string,\n    model: string,\n    params: Record<string, any>,\n    files?: WiroFileParam[]\n  ): Promise<RunResponse & { data?: T }> {\n    const authHeaders = generateAuthHeaders(this.apiKey, this.apiSecret);\n    const url = `${this.baseUrl}/Run/${owner}/${model}`;\n\n    let body: FormData | string;\n    let headers: Record<string, string>;\n\n    // When files are present, construct a FormData body. Otherwise send JSON.\n    if (files && files.length > 0) {\n      const form = new FormData();\n      \n      // Append provided parameters to the form\n      if (params) {\n        for (const [key, value] of Object.entries(params)) {\n          if (value === undefined || value === null) continue;\n          \n          if (Array.isArray(value)) {\n            // FormData supports duplicate keys for arrays\n            value.forEach(v => form.append(key, String(v)));\n          } else {\n            form.append(key, String(value));\n          }\n        }\n      }\n      \n      // Append files to the form\n      for (const fileParam of files) {\n        let fileData: Blob | File;\n        let filename = fileParam.filename;\n\n        // If the file is a string, treat it as a path and read using Bun.file()\n        if (typeof fileParam.file === 'string') {\n          try {\n            const bunFile = Bun.file(fileParam.file);\n            fileData = bunFile;\n\n            // Extract filename from path if not provided\n            if (!filename) {\n              const pathParts = fileParam.file.split(/[/\\\\]/);\n              filename = pathParts[pathParts.length - 1] || fileParam.name;\n            }\n          } catch (error) {\n            const errorMsg = error instanceof Error ? error.message : String(error);\n            throw new Error(`Failed to read file at \"${fileParam.file}\": ${errorMsg}`);\n          }\n        } else {\n          // File is already a Blob or File\n          fileData = fileParam.file;\n\n          // Use the File's name if available, otherwise generate one\n          if (!filename) {\n            if ('name' in fileData && fileData.name) {\n              filename = fileData.name;\n            } else {\n              filename = `${fileParam.name}.bin`;\n            }\n          }\n        }\n\n        form.append(fileParam.name, fileData, filename);\n      }\n      \n      body = form;\n      // Don't set Content-Type - let fetch set it with the boundary\n      headers = { ...authHeaders };\n    } else {\n      // Send parameters as JSON\n      body = JSON.stringify(params);\n      headers = {\n        ...authHeaders,\n        'Content-Type': 'application/json',\n      };\n    }\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers,\n      body,\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Wiro API request failed: ${response.status} ${response.statusText} - ${errorText}`);\n    }\n\n    return response.json() as Promise<RunResponse & { data?: T }>;\n  }\n\n  /**\n   * Retrieve details about one or more tasks. You can supply either a task ID or a\n   * socket access token. At least one of these properties must be provided.\n   *\n   * @param taskInfo - An object containing either a `taskid` or `tasktoken` field\n   * @returns Promise resolving to task details including status and outputs\n   * \n   * @example\n   * ```ts\n   * // Get task by ID\n   * const detail = await client.getTaskDetail({ taskid: '2221' });\n   * \n   * // Get task by token\n   * const detail = await client.getTaskDetail({ \n   *   tasktoken: 'eDcCm5yyUfIvMFspTwww49OUfgXkQt' \n   * });\n   * \n   * // Check task status\n   * const task = detail.tasklist[0];\n   * if (task.status === 'task_postprocess_end') {\n   *   console.log('Task completed!', task.outputs);\n   * }\n   * ```\n   */\n  async getTaskDetail<T = any>(taskInfo: TaskDetailRequest): Promise<TaskDetailResponse<T>> {\n    if (!taskInfo.taskid && !taskInfo.tasktoken) {\n      throw new Error('getTaskDetail requires either a taskid or a tasktoken');\n    }\n\n    const authHeaders = generateAuthHeaders(this.apiKey, this.apiSecret);\n    const url = `${this.baseUrl}/Task/Detail`;\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        ...authHeaders,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(taskInfo),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Wiro API request failed: ${response.status} ${response.statusText} - ${errorText}`);\n    }\n\n    return response.json() as Promise<TaskDetailResponse<T>>;\n  }\n\n  /**\n   * Kill a running task. Provide either the task ID or the socket access token.\n   * Use this to terminate tasks that are currently executing.\n   *\n   * @param taskInfo - An object containing either `taskid` or `tasktoken`\n   * @returns Promise resolving to the kill task response\n   * \n   * @example\n   * ```ts\n   * // Kill by task ID\n   * await client.killTask({ taskid: '534574' });\n   * \n   * // Kill by token\n   * await client.killTask({ \n   *   tasktoken: 'ZpYote30on42O4jjHXNiKmrWAZqbRE' \n   * });\n   * ```\n   */\n  async killTask(taskInfo: KillTaskRequest): Promise<KillTaskResponse> {\n    if (!taskInfo.taskid && !taskInfo.tasktoken) {\n      throw new Error('killTask requires either a taskid or a tasktoken');\n    }\n\n    const authHeaders = generateAuthHeaders(this.apiKey, this.apiSecret);\n    const url = `${this.baseUrl}/Task/Kill`;\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        ...authHeaders,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(taskInfo),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Wiro API request failed: ${response.status} ${response.statusText} - ${errorText}`);\n    }\n\n    return response.json() as Promise<KillTaskResponse>;\n  }\n\n  /**\n   * Cancel a queued task by its task ID. Use this for tasks that are waiting in the queue\n   * and have not started execution yet.\n   *\n   * @param taskid - The task ID to cancel\n   * @returns Promise resolving to the cancel task response\n   * \n   * @example\n   * ```ts\n   * await client.cancelTask('634574');\n   * ```\n   */\n  async cancelTask(taskid: string): Promise<CancelTaskResponse> {\n    const authHeaders = generateAuthHeaders(this.apiKey, this.apiSecret);\n    const url = `${this.baseUrl}/Task/Cancel`;\n\n    const response = await fetch(url, {\n      method: 'POST',\n      headers: {\n        ...authHeaders,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({ taskid }),\n    });\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`Wiro API request failed: ${response.status} ${response.statusText} - ${errorText}`);\n    }\n\n    return response.json() as Promise<CancelTaskResponse>;\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "D319ED8A1EB299F364756E2164756E21",
  "names": []
}